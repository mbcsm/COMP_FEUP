
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
/*
options {
  LOOKAHEAD = 1;
  CHOICE_AMBIGUITY_CHECK = 2;
  OTHER_AMBIGUITY_CHECK = 1;
  STATIC = true;
  DEBUG_PARSER = false;
  DEBUG_LOOKAHEAD = false;
  DEBUG_TOKEN_MANAGER = false;
  ERROR_REPORTING = true;
  JAVA_UNICODE_ESCAPE = false;
  UNICODE_INPUT = false;
  IGNORE_CASE = false;
  USER_TOKEN_MANAGER = false;
  USER_CHAR_STREAM = false;
  BUILD_PARSER = true;
  BUILD_TOKEN_MANAGER = true;
  SANITY_CHECK = true;
  FORCE_LA_CHECK = false;
} */

PARSER_BEGIN(Parser)

public class Parser {
  
  public static void main(String args[]) throws ParseException {

    System.out.println("JavaCC Parser:  Reading from file " + "testfile.java" + " . . .");
    try {
      parser = new JavaCCParser(new java.io.FileInputStream("testfile.java"));
    } catch (java.io.FileNotFoundException e) {
      System.out.println("JavaCC Parser:  File " + "testfile.java" + " not found.");
      return;
    }
    try {
      parser.javacc_input();
      System.out.println("JavaCC Parser:  Java program parsed successfully.");
    } catch (ParseException e) {
      System.out.println(e.getMessage());
      System.out.println("JavaCC Parser:  Encountered errors during parse.");
    }
    
  }

}

PARSER_END(Parser)

/* SKIP (.ignore) */
SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
}

/* GRAMMAR RULES */
void PROGRAM(): {}
{
  PROGRAM() <EOF>
}
void CLASSDEC(): {}
{
  <CLASS> <IDENT> (<EXTENDS> | <IDENT>) <LBRACE> (VARDEC())* (<MAINDEC> | <METHODDEC>)* <RBRACE>
}
void VARDEC(): {}
{
  TYPE() <IDENT> <SEMICOLON>
}
void VARDECLIST(): {}
{
  TYPE() <IDENT> (<COMMA> TYPE() <IDENT>)*
}
void MAINDEC(): {}
{
  <PUBLIC> <STATIC> <VOID> <MAIN> <LPARENTHESIS> <STRING> <BRACKETS> <IDENT> <RPARENTHESIS> <LBRACE>
  (VARDEC())* (<STATEMENT>)* <RBRACE>
}
void METHODDEC(): {}
{
  <PUBLIC> TYPE() <IDENT> <LPARENTHESIS> (VARDECLIST())? <RPARENTHESIS> <LBRACE>
  (VARDEC())* (<STATEMENT>)* <RETURN> <EXPRESSION> <SEMICOLON> <RBRACE>
}
void TYPE(): {}
{
  (("int" (<BRACKETS>)?) | "boolean" | <IDENT>)
}
void STATEMENT(): {}
{
  (  (<LBRACE> (STATEMENT())* <RBRACE>)
  | (<IF> <LPARENTHESIS> <EXPRESSION> <RPARENTHESIS> STATEMENT() <ELSE> STATEMENT())
  | (<WHILE> <LPARENTHESIS> <EXPRESSION> <RPARENTHESIS> STATEMENT())
  | (<EXPRESSION> <SEMICOLON>)
  | (<IDENT> (SINGLE() | ARRAY()))
  )
}
void SINGLE(): {}
{
  <ASSIGN> <EXPRESSION> <SEMICOLON>
}
void ARRAY(): {}
{
  <LBRACE> <EXPRESSION> <RBRACE> <ASSIGN> <EXPRESSION> <SEMICOLON>
}

/* TOKENS (TERMINALS) */
TOKEN : 
{
  <CLASS: "class">    | <EXTENDS: "extends">  | 
  <PUBLIC: "public">  | <STATIC: "public">    | 
  <VOID: "void">      | <MAIN: "main">        |
  <RETURN: "return">  |
 
  <STRING: "string"> |

  <IF : "if"> | <ELSE | "else"> | <WHILE : "while"> |

  <ASSIGN : "="> |

  <LBRACE: "{"> |  <RBRACE: "}"> | 
  <LPARENTHESIS: "("> | <RPARENTHESIS: ")"> |
  <BRACKETS: "[]"> | <SEMICOLON: ";"> | <COMMA: ",">
  <IDENT: "a-z",{"0-9a-zA-Z"}> |
  <OP: "+"|"-"|"*"|"/"> |
  <CMP: "<"|"&&">

}

/* COMMENTS */

MORE :
{
  "//" : IN_SINGLE_LINE_COMMENT
|
  <"/**" ~["/"]> { input_stream.backup(1); } : IN_FORMAL_COMMENT
|
  "/*" : IN_MULTI_LINE_COMMENT
}

<IN_SINGLE_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <SINGLE_LINE_COMMENT: "\n" | "\r" | "\r\n" > : DEFAULT
}

<IN_FORMAL_COMMENT>
SPECIAL_TOKEN :
{
  <FORMAL_COMMENT: "*/" > : DEFAULT
}

<IN_MULTI_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <MULTI_LINE_COMMENT: "*/" > : DEFAULT
}

<IN_SINGLE_LINE_COMMENT,IN_FORMAL_COMMENT,IN_MULTI_LINE_COMMENT>
MORE :
{
  < ~[] >
}

/** Root production. */
void Input() :
{ int count; }
{
  count=MatchedBraces() <EOF>
  { System.out.println("The levels of nesting is " + count); }
}

/** Brace counting production. */
int MatchedBraces() :
{ int nested_count=0; }
{
  <LBRACE> [ nested_count=MatchedBraces() ] <RBRACE>
  { return ++nested_count; }
}
